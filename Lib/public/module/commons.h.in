#pragma once

#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <unistd.h>
#include <time.h>

#define MODULE_VERSION_MAJ @PROJECT_VERSION_MAJOR@
#define MODULE_VERSION_MIN @PROJECT_VERSION_MINOR@
#define MODULE_VERSION_PAT @PROJECT_VERSION_PATCH@

/* 
 * ctors order: 
 * 0) m_pre_start()
 * 1) libmodule_init()
 * 2) each module_pre_start() (only module_easy API)
 * 3) each module ctor function (only module_easy API)
 * 
 * dtors order:
 * 1) each module's dtor function (only module_easy API)
 * 0) libmodule_destroy()
 */
#define _ctor0_     __attribute__((constructor (110)))
#define _ctor1_     __attribute__((constructor (111)))
#define _ctor2_     __attribute__((constructor (112)))
#define _ctor3_     __attribute__((constructor (113)))
#define _dtor0_     __attribute__((destructor (110)))
#define _dtor1_     __attribute__((destructor (111)))

#define _pure_      __attribute__((pure))
#define _weak_      __attribute__((weak))
#define _public_    __attribute__ ((visibility("default")))

#define M_CTX_DEFAULT  "default"
#define M_CTX_MAX_EVENTS   64

/** Structs types **/

/* Incomplete structure declaration to self handler */
typedef struct _self self_t;

/* Modules flags */
typedef enum {
    MOD_NAME_DUP        = 0x01,         // Should module's name be strdupped?
    MOD_NAME_AUTOFREE   = 0x02,         // Should module's name be autofreed?
    MOD_ALLOW_REPLACE   = 0x04,         // Can module be replaced by another module with same name?
    MOD_PERSIST         = 0x08,         // Module cannot be deregistered by directly call to module_deregister (or by FS delete) while its context is looping
    CTX_NAME_DUP        = 0x01 << 8,    // Should ctx's name be strdupped? (only if a ctx is created during a register)
    CTX_NAME_AUTOFREE   = 0x02 << 8     // Should ctx's name be autofreed? (only if a ctx is created during a register)
} mod_flags;

/* Modules states */
typedef enum { IDLE = 0x01, RUNNING = 0x02, PAUSED = 0x04, STOPPED = 0x08, ZOMBIE = 0x10 } mod_states;

/* PubSub message types */
typedef enum { USER, LOOP_STARTED, LOOP_STOPPED, MODULE_STARTED, MODULE_STOPPED, MODULE_POISONPILL } ps_msg_type;

/* Module event sources' types */
typedef enum {
    TYPE_PS,    // PubSub Source
    TYPE_FD,    // FD Source
    TYPE_TMR,   // Timer Source
    TYPE_SGN,   // Signal Source
    TYPE_PATH,  // Path Source
    TYPE_PID,   // PID Source
    TYPE_TASK,  // Task source -> SRC_ONESHOT flag is forced
    TYPE_END    // End of supported sources
} mod_src_types;

/* 
 * Module event sources' flags:
 * First 8 bits are reserved for generic source flags.
 * Then, each source type has 8 bits reserved for its flags.
 */
#define FLAG_SHIFT(type, val)   val << (8 * (type + 1))
typedef enum { 
    SRC_AUTOFREE        =       0x01, // Automatically free userdata upon deregistation.
    SRC_ONESHOT         =       0x02, // Run just once then automatically deregister source.
    SRC_DUP             =       0x04, // Duplicate PubSub topic or source fd.
    SRC_FD_AUTOCLOSE    =       FLAG_SHIFT(TYPE_FD, 0x01), // Automatically close fd upon deregistation.
    SRC_TMR_ABSOLUTE    =       FLAG_SHIFT(TYPE_TMR, 0x01) // Absolute timer
} mod_src_flags;

/* 
 * Module's pubsub API flags (module_tell(), module_publish(), module_broadcast())
 */
typedef enum {
    PS_AUTOFREE = 0x01,     // Autofree PubSub data after every recipient receives message (ie: when ps_msg ref counter goes to 0)
    PS_GLOBAL   = 0x02,     // Only useful for module_broadcast. Broadcast a message to every context.
    PS_DUP_DATA = 0x04      // Automatically duplicate sent data  (malloc message size + memcpy). Useful when sending data allocated on stack.
} mod_ps_flags;

/* module_register_src() request special types. */
typedef struct {
    clockid_t clock_id;     // Clock_id (eg: CLOCK_MONOTONIC). Unsupported on libkqueue/kqueue
    uint64_t ms;            // Timer in ms
} mod_tmr_t;

typedef struct {
    unsigned int signo;     // Requested signal number source, as defined in signal.h
} mod_sgn_t;

typedef struct {
    const char *path;       // Path of file/folder to which subscribe for events
    unsigned int events;    // Desired events
} mod_path_t;

typedef struct {
    pid_t pid;              // Desired process id
    unsigned int events;    // Desired events. Unused on linux: only process exit is supported
} mod_pid_t;

typedef struct {
    unsigned int tid;       // Desired thread id
    int (*fn)(void *);      // Function to be run on thread
} mod_task_t;

/** Libmodule sub-messages received in receive() callback **/

/* PubSub message */
typedef struct {
    ps_msg_type type;
    const self_t *sender;   // Sender reference
    const char *topic;
    const void *data;
    ssize_t size;
} ps_msg_t;

/* FD event message */
typedef struct {
    int fd;
} fd_msg_t;

/* Timer event message */
typedef struct {
    uint64_t ms;
} tmr_msg_t;

/* Signal event message */
typedef struct {
    unsigned int signo;
} sgn_msg_t;

/* Path event message */
typedef struct {
    const char *path;
    unsigned int events;
} path_msg_t;

/* Pid event message */
typedef struct {
    pid_t pid;
    unsigned int events;
} pid_msg_t;

/* Task event message */
typedef struct {
    unsigned int tid;
    int retval;
} task_msg_t;

/* Libmodule receive() main message type */
typedef struct {
    const self_t *self;
    const mod_src_types type;
    union {
        const fd_msg_t      *fd_msg;
        const ps_msg_t      *ps_msg;
        const tmr_msg_t     *tmr_msg;
        const sgn_msg_t     *sgn_msg;
        const path_msg_t    *pt_msg;
        const pid_msg_t     *pid_msg;
        const task_msg_t    *task_msg;
    };
} msg_t;

/* Callbacks typedefs */
typedef bool (*init_cb)(void);
typedef bool (*eval_cb)(void);
typedef void (*recv_cb)(const msg_t *const msg, const void *userdata);
typedef void (*destroy_cb)(void);

/* Logger callback */
typedef void (*log_cb)(const self_t *self, const char *fmt, va_list args);

/* Memory management user-passed functions */
typedef void *(*malloc_fn)(size_t size);
typedef void *(*realloc_fn)(void *ptr, size_t size);
typedef void *(*calloc_fn)(size_t nmemb, size_t size);
typedef void (*free_fn)(void *ptr);

/* Struct that holds user defined callbacks */
typedef struct {
    init_cb init;                           // module's init function
    eval_cb eval;                           // module's state changed function
    recv_cb recv;                           // module's recv function
    destroy_cb destroy;                     // module's destroy function
} userhook_t;

/* Struct that holds user defined memory functions */
typedef struct {
    malloc_fn _malloc;
    realloc_fn _realloc;
    calloc_fn _calloc;
    free_fn _free;
} memhook_t;

typedef struct {
    uint64_t inactive_ms;
    double activity_freq;
} stats_t;

/* Common to any context; set this in modules_pre_start() */
_public_ int m_set_memhook(const memhook_t *hook);
