#pragma once

#if (!defined LIBMODULE_CORE_H && !defined LIBMODULE_STRUCT_H && !defined LIBMODULE_MEM_H && !defined LIBMODULE_TH_H)
    #error "Libmodule cmn.h should not be explicitly included."
#endif

#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <unistd.h>
#include <time.h>
#include <pthread.h>

#define MODULE_VERSION_MAJ @PROJECT_VERSION_MAJOR@
#define MODULE_VERSION_MIN @PROJECT_VERSION_MINOR@
#define MODULE_VERSION_PAT @PROJECT_VERSION_PATCH@

/* 
 * ctors order: 
 * 0) m_pre_start()
 * 1) libmodule_init()
 * 2) M_CTX() macro ctors (only ctx_easy API) 
 * 3) each module_pre_start() (only mod_easy API)
 * 4) each module ctor function (only mod_easy API)
 * 
 * dtors order:
 * 2) each module's dtor function (only mod_easy API)
 * 1) each context's dtor function (only ctx_easy API)
 * 0) libmodule_destroy()
 */
#define _ctor0_         __attribute__((constructor (110)))
#define _ctor1_         __attribute__((constructor (111)))
#define _ctor2_         __attribute__((constructor (112)))
#define _ctor3_         __attribute__((constructor (113)))
#define _ctor4_         __attribute__((constructor (114)))
#define _dtor0_         __attribute__((destructor (110)))
#define _dtor1_         __attribute__((destructor (111)))
#define _dtor2_         __attribute__((destructor (112)))

/** Structs types **/

/* Incomplete structure declaration to mod handler */
typedef struct _mod m_mod_t;

/* Incomplete structure declaration to ctx handler */
typedef struct _ctx m_ctx_t;

/* Forward declaration for thpool, used in m_task_t */
typedef struct _thpool m_thpool_t;

/* PubSub message types */
typedef enum { M_PS_USER, M_PS_CTX_STARTED, M_PS_CTX_STOPPED, M_PS_MOD_STARTED, M_PS_MOD_STOPPED, M_PS_MOD_POISONPILL } m_ps_types;

/* Module event sources' types */
typedef enum {
    M_SRC_TYPE_PS,    // PubSub Source
    M_SRC_TYPE_FD,    // FD Source
    M_SRC_TYPE_TMR,   // Timer Source
    M_SRC_TYPE_SGN,   // Signal Source
    M_SRC_TYPE_PATH,  // Path Source
    M_SRC_TYPE_PID,   // PID Source
    M_SRC_TYPE_TASK,  // Task source -> SRC_ONESHOT flag is forced
    M_SRC_TYPE_END    // End of supported sources
} m_src_types;

/* 
 * Module event sources' flags:
 * First 8 bits are reserved for common source flags.
 * Then, each source type has 8 bits reserved for its flags.
 */
#define M_SRC_SHIFT(type, val)   val << (8 * (type + 1))
typedef enum {
    M_SRC_AUTOFREE        =       0x01, // Automatically free userdata upon source deregistation.
    M_SRC_ONESHOT         =       0x02, // Run just once then automatically deregister source.
    M_SRC_DUP             =       0x04, // Duplicate PubSub topic, source fd or source path.
    M_SRC_PS_PRIO_LOWEST  =       M_SRC_SHIFT(M_SRC_TYPE_PS, 0x01), // PubSub subscription low priority
    M_SRC_PS_PRIO_LOW     =       M_SRC_SHIFT(M_SRC_TYPE_PS, 0x02), // PubSub subscription low priority
    M_SRC_PS_PRIO_NORM    =       M_SRC_SHIFT(M_SRC_TYPE_PS, 0x04), // PubSub subscription mid priority (default)
    M_SRC_PS_PRIO_HIGH    =       M_SRC_SHIFT(M_SRC_TYPE_PS, 0x08), // PubSub subscription high priority
    M_SRC_PS_PRIO_HIGHEST =       M_SRC_SHIFT(M_SRC_TYPE_PS, 0x10), // PubSub subscription high priority
    M_SRC_FD_AUTOCLOSE    =       M_SRC_SHIFT(M_SRC_TYPE_FD, 0x01), // Automatically close fd upon deregistation.
    M_SRC_TMR_ABSOLUTE    =       M_SRC_SHIFT(M_SRC_TYPE_TMR, 0x01) // Absolute timer
} m_src_flags;

/* 
 * Module's pubsub API flags (module_tell(), module_publish(), module_broadcast())
 */
typedef enum {
    M_PS_AUTOFREE   = 0x01,     // Autofree PubSub data after every recipient receives message (ie: when ps_msg ref counter goes to 0)
    M_PS_GLOBAL     = 0x02      // Only useful for module_broadcast. Broadcast a message to any context.
} m_ps_flags;

/* m_mod_src_register() special types (ie: input types to register a src) */
typedef struct {
    clockid_t clock_id;     // Clock_id (eg: CLOCK_MONOTONIC). Unsupported on libkqueue/kqueue
    uint64_t ms;            // Timer in ms
} m_src_tmr_t;

typedef struct {
    unsigned int signo;     // Requested signal number source, as defined in signal.h
} m_src_sgn_t;

typedef struct {
    const char *path;       // Path of file/folder to which subscribe for events
    unsigned int events;    // Desired events
} m_src_path_t;

typedef struct {
    pid_t pid;              // Desired process id
    unsigned int events;    // Desired events. Unused on linux: only process exit is supported
} m_src_pid_t;

typedef struct {
    unsigned int tid;       // Desired thread id
    int (*fn)(void *);      // Function to be run on thread
    m_thpool_t *thpool;     // optional threadpool on which job should run
} m_src_task_t;

/** Libmodule output messages received in receive() callback **/

/* PubSub messages */
typedef struct {
    m_ps_types type;
    const m_mod_t *sender;
    const char *topic;
    const void *data;
} m_evt_ps_t;

/* Generic fd event messages */
typedef struct {
    int fd;
} m_evt_fd_t;

/* Timer event messages */
typedef struct {
    uint64_t ms;
} m_evt_tmr_t;

/* Signal event messages */
typedef struct {
    unsigned int signo;
} m_evt_sgn_t;

/* Path event messages */
typedef struct {
    const char *path;
    unsigned int events;
} m_evt_path_t;

/* Pid event messages */
typedef struct {
    pid_t pid;
    unsigned int events;
} m_evt_pid_t;

/* Task event messages */
typedef struct {
    unsigned int tid;
    int retval;
} m_evt_task_t;

/* Libmodule receive() main message type */
typedef struct {
    const m_mod_t *self;                            // Self reference. Mostly useful when 2+ modules share same receive() callback
    m_src_types type;                               // Event type
    union {                                         // Events
        m_evt_fd_t      *fd_msg;
        m_evt_ps_t      *ps_msg;
        m_evt_tmr_t     *tmr_msg;
        m_evt_sgn_t     *sgn_msg;
        m_evt_path_t    *pt_msg;
        m_evt_pid_t     *pid_msg;
        m_evt_task_t    *task_msg;
    };
    const void *userdata;                           // Event userdata, passed through m_mod_src_register()
} m_evt_t;

/* Memory management user-passed functions */
typedef void *(*m_malloc_fn)(size_t size);
typedef void *(*m_realloc_fn)(void *ptr, size_t size);
typedef void *(*m_calloc_fn)(size_t nmemb, size_t size);
typedef void (*m_free_fn)(void *ptr);

/* Struct that holds user defined memory functions */
typedef struct {
    m_malloc_fn _malloc;
    m_realloc_fn _realloc;
    m_calloc_fn _calloc;
    m_free_fn _free;
} m_memhook_t;

typedef struct {
    uint64_t inactive_ms;
    double activity_freq;
} m_stats_t;

/* 
 * Common to any context; set this in m_pre_start(), 
 * ie: before library is inited and internal structures allocated 
 */
int m_set_memhook(const m_memhook_t *hook);
