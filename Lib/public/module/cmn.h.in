#pragma once

#if (!defined LIBMODULE_CORE_H && !defined LIBMODULE_STRUCT_H && !defined LIBMODULE_MEM_H && !defined LIBMODULE_TH_H)
    #error "Libmodule cmn.h should not be explicitly included."
#endif

#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <unistd.h>
#include <time.h>
#include <pthread.h>

#define LIBMODULE_VERSION_MAJ @PROJECT_VERSION_MAJOR@
#define LIBMODULE_VERSION_MIN @PROJECT_VERSION_MINOR@
#define LIBMODULE_VERSION_PAT @PROJECT_VERSION_PATCH@

/*
 * ctors order:
 * 0) global m_pre_start(), usefult to set your own memhook if desired
 * 1) internal libmodule_init()
 * 2) each m_mod_pre_start() (only mod_easy API)
 * 3) each m_mod_ctor() (only mod_easy API)
 *
 * dtors order:
 * 1) each m_mod_dtor() (only mod_easy API)
 * 0) internal libmodule_deinit()
 */
#define _m_ctor0_         __attribute__((constructor (110)))
#define _m_ctor1_         __attribute__((constructor (111)))
#define _m_ctor2_         __attribute__((constructor (113)))
#define _m_ctor3_         __attribute__((constructor (114)))
#define _m_dtor0_         __attribute__((destructor (110)))
#define _m_dtor1_         __attribute__((destructor (111)))

/** Structs types **/

/* Incomplete structure declaration to mod and ctx handlers */
typedef struct _mod m_mod_t;
typedef struct _ctx m_ctx_t;

/* Forward declaration for thpool, used in m_task_t */
typedef struct _thpool m_thpool_t;

/* 
 * Modules flags, leave upper 16b for module permissions management;
 * First 8 bits are constant flags.
 * There is still no API to update set flags though.
 */
#define M_MOD_FL_PERM(val)         val << 16
#define M_MOD_FL_MODIFIABLE(val)   val << 8
typedef enum {
    M_MOD_NAME_DUP          = 1 << 0,         // Should module's name be strdupped? (force M_MOD_NAME_AUTOFREE flag)
    M_MOD_NAME_AUTOFREE     = 1 << 1,         // Should module's name be autofreed?
    M_MOD_ALLOW_REPLACE     = M_MOD_FL_MODIFIABLE(1 << 0),         // Can module be replaced by another module with same name?
    M_MOD_PERSIST           = M_MOD_FL_MODIFIABLE(1 << 1),         // Module cannot be deregistered by direct call to m_mod_deregister (or by FS delete) while its context is looping
    M_MOD_USERDATA_AUTOFREE = M_MOD_FL_MODIFIABLE(1 << 2),         // Automatically free module userdata upon deregister
    M_MOD_DENY_CTX          = M_MOD_FL_PERM(1 << 0), // Deny access to module's ctx through m_mod_ctx() (it means the module won't be able to call ctx API)
    M_MOD_DENY_PUB          = M_MOD_FL_PERM(1 << 1), // Deny access to module's publishing functions: m_mod_ps_{tell,publish,broadcast,poisonpill}
    M_MOD_DENY_SUB          = M_MOD_FL_PERM(1 << 2), // Deny access to m_mod_ps_(un)subscribe()
} m_mod_flags;

/* PubSub message types */
typedef enum {
    M_PS_USER,
    M_PS_CTX_STARTED,
    M_PS_CTX_STOPPED,
    M_PS_MOD_STARTED,
    M_PS_MOD_STOPPED,
    M_PS_MOD_POISONPILL
} m_ps_types;

/* Module event sources' types */
typedef enum {
    M_SRC_TYPE_PS,    // PubSub Source
    M_SRC_TYPE_FD,    // FD Source
    M_SRC_TYPE_TMR,   // Timer Source
    M_SRC_TYPE_SGN,   // Signal Source
    M_SRC_TYPE_PATH,  // Path Source
    M_SRC_TYPE_PID,   // PID Source
    M_SRC_TYPE_TASK,  // Task source -> M_SRC_ONESHOT flag is forced
    M_SRC_TYPE_THRESH,// Threshold source -> M_SRC_ONESHOT flag is forced
    M_SRC_TYPE_END    // End of supported sources
} m_src_types;

/*
 * Module event sources' flags:
 * First 8 bits are reserved for common source flags.
 * Then, each source type has 8 bits reserved for its flags.
 */
#define M_SRC_SHIFT(type, val)   val << (8 * (type + 1))
typedef enum {
    M_SRC_PRIO_LOW        =       1 << 0, // PubSub subscription low priority
    M_SRC_RIO_NORM        =       1 << 1, // PubSub subscription mid priority (default)
    M_SRC_PRIO_HIGH       =       1 << 2, // PubSub subscription high priority
    M_SRC_AUTOFREE        =       1 << 3, // Automatically free userdata upon source deregistation.
    M_SRC_ONESHOT         =       1 << 4, // Run just once then automatically deregister source.
    M_SRC_DUP             =       1 << 5, // Duplicate PubSub topic, source fd or source path.
    M_SRC_FD_AUTOCLOSE    =       M_SRC_SHIFT(M_SRC_TYPE_FD, 1 << 0), // Automatically close fd upon deregistation.
    M_SRC_TMR_ABSOLUTE    =       M_SRC_SHIFT(M_SRC_TYPE_TMR, 1 << 0), // Absolute timer
} m_src_flags;

/*
 * Module's pubsub API flags (module_tell(), module_publish(), module_broadcast())
 */
typedef enum {
    M_PS_AUTOFREE   = 1 << 0,     // Autofree PubSub data after every recipient receives message (ie: when ps_evt ref counter goes to 0)
} m_ps_flags;

/** Libmodule input src types for m_mod_src_register() API **/

typedef struct {
    clockid_t clock_id;     // Clock_id (eg: CLOCK_MONOTONIC). Unsupported on libkqueue/kqueue
    uint64_t ms;            // Timer in ms
} m_src_tmr_t;

typedef struct {
    unsigned int signo;     // Requested signal number source, as defined in signal.h
} m_src_sgn_t;

typedef struct {
    const char *path;       // Path of file/folder to which subscribe for events
    unsigned int events;    // Desired events
} m_src_path_t;

typedef struct {
    pid_t pid;              // Process id to be watched
    unsigned int events;    // Desired events. Unused on linux: only process exit is supported
} m_src_pid_t;

typedef struct {
    int tid;                // Unique task id; it allows to run multiple times the same fn
    int (*fn)(void *);      // Function to be run on thread
} m_src_task_t;

typedef struct {
    uint64_t inactive_ms;   // if != 0 -> if module is inactive for longer than this, an alarm will be received
    double activity_freq;   // if != 0 -> if module's activity is higher than this, an alarm will be received
} m_src_thresh_t;

/** Libmodule output messages received in receive() callback **/

/* PubSub messages */
typedef struct {
    m_ps_types type;
    const m_mod_t *sender;
    const char *topic;
    const void *data;
} m_evt_ps_t;

/* Generic fd event messages */
typedef struct {
    int fd;
} m_evt_fd_t;

/* Timer event messages */
typedef struct {
    uint64_t ms;
} m_evt_tmr_t;

/* Signal event messages */
typedef struct {
    unsigned int signo;
} m_evt_sgn_t;

/* Path event messages */
typedef struct {
    const char *path;
    unsigned int events;
} m_evt_path_t;

/* Pid event messages */
typedef struct {
    pid_t pid;
    unsigned int events;
} m_evt_pid_t;

/* Task event messages */
typedef struct {
    unsigned int tid;
    int retval;
} m_evt_task_t;

/* Thresh event messages */
typedef struct {
    unsigned int id;
    uint64_t inactive_ms;
    double activity_freq;
} m_evt_thresh_t;

/* Libmodule receive() main message type */
typedef struct {
    m_src_types type;                               // Event type
    union {                                         // Events
        m_evt_fd_t      *fd_evt;
        m_evt_ps_t      *ps_evt;
        m_evt_tmr_t     *tmr_evt;
        m_evt_sgn_t     *sgn_evt;
        m_evt_path_t    *path_evt;
        m_evt_pid_t     *pid_evt;
        m_evt_task_t    *task_evt;
        m_evt_thresh_t  *thresh_evt;
    };
    const void *userdata;                           // Event userdata, passed through m_mod_src_register()
} m_evt_t;

/* Struct that holds user defined memory functions */
typedef struct {
    void *(*_malloc)(size_t size);
    void *(*_calloc)(size_t nmemb, size_t size);
    void (*_free)(void *ptr);
} m_memhook_t;

/*
 * Common to any context; set this in m_pre_start(),
 * ie: before library is inited and internal structures allocated
 */
int m_set_memhook(const m_memhook_t *hook);
